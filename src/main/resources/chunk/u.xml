<?xml version="1.0" encoding="UTF-8"?>

<!-- 
Utterance
Schema - http://www.talkbank.org/software/talkbank.xsd
XPath -	/xs:schema/xs:complexType[@name="speakerUtteranceType"]
-->
<chunk xmlns="http://phon.ling.mun.ca/ns/chunk">
    
    <!-- Parser -->
    <buffer name="Chat.g">
        <![CDATA[
u
	:	U_START U_ATTR_WHO? ( uele )* t? postcode? media? a* U_END 
	->	^(U_START U_ATTR_WHO? uele* t? postcode? media? a*)
	;
	catch [RecognitionException re] {
		consumeUntil(input, U_END);
		input.consume(); // consume U_END
	}
	
uele
	:	ugrp
	|	uannotation
	;
	
ugrp
	:	w 
	|	pg 
	|	g
	;
	
uannotation
	: 	s 
	|	pause 
	|	e
	|	linker
	|	tagmarker
	;
]]>
    </buffer>
    
    <!-- Tree Walker -->
    <buffer name="ChatTree.g">
        <![CDATA[
u
scope {
	IUtterance utt;
	
	// when adding annotations, sometimes we need to create
	// the first word-group.  This flag tells the next ugrp
	// element to use the last group instead of making a new one
	boolean useLastGroup;
}
@init {
	$u::utt = session.newUtterance();
	$u::useLastGroup = false;
}
@after {

	if($u::utt.getMedia() == null)
	{
		IMedia m = IPhonFactory.getDefaultFactory().createMedia();
		m.setStartValue(0L);
		m.setEndValue(0L);
		m.setUnitType(MediaUnit.Millisecond);
		$u::utt.setMedia(m);
	}

	uttIndex++;
}
	:	^(U_START who=U_ATTR_WHO? uele* t? postcode? seg=media? a*)
	{
		// setup speaker
		if($who != null) 
		{
			// try to find the speaker
			String partId = $who.text;
			
			// by id first
			for(IParticipant p:session.getParticipants()) {
				if(p.getId().equals(partId)) {
					$u::utt.setSpeaker(p);
					break;
				}
			}
			
		}
		
		// set media if avail
		if($seg.val != null)
		{
			$u::utt.setMedia($seg.val);
		}
	}
	;

uele
	:	ugrp
	|	uannotation
	;

/**
 * Each ugrp object creates a new group in Phon.
 */
 ugrp
 scope {
 	IWord w;
 	
 }
 @init {
 	if($u::useLastGroup) {
 		List<IWord> grps = $u::utt.getWords();
 		$ugrp::w = grps.get(grps.size()-1);
 		
 		// reset flag
 		$u::useLastGroup = false;
 	} else {
 		$ugrp::w = $u::utt.newWordGroup();
 	}
 }
	:	w 
	{	
		$ugrp::w.setWord(
			($ugrp::w.getWord().length() > 0 ? $ugrp::w.getWord() + " " : "") +
			$w.val);
	}
	| 	pg 
	{	
		$ugrp::w.setWord(
			($ugrp::w.getWord().length() > 0 ? $ugrp::w.getWord() + " " : "") +
			$pg.val);
	}
	| 	g
	{	
		// we may need to break data up into more words
		// check to see if we have sub-[] enclosures
		String gData = $g.val;
		if(gData.contains("[") || gData.contains("]")) {
			// break up data
			List<String> grps = new ArrayList<String>();
			String currentGrp = "";
			for(int i = 0; i < gData.length(); i++) {
				char c = gData.charAt(i);
				
				if(c == '[') {
	                if(StringUtils.strip(currentGrp).length() > 0) {
	                    grps.add(StringUtils.strip(currentGrp));
	                }
	                currentGrp = "";
	            }
	            currentGrp += c;
	            if(c == ']') {
	                if(StringUtils.strip(currentGrp).length() > 0) {
	                    grps.add(StringUtils.strip(currentGrp));
	                }
	                currentGrp = "";
	            }
					
			}
			if(StringUtils.strip(currentGrp).length() > 0) {
				grps.add(StringUtils.strip(currentGrp));
			}
			// place only an openeing '{' in our first group
			// this tells the tree builder   to create this group surrounding the 
			// next <pg> groups
			$ugrp::w.setWord("{");
			
			// if we have sub-pg groups.  The new words should have been created.
			int phoRepIndex = 0;
			for(String g:grps) {
				IWord nextWord = $u::utt.newWord();
				
				if(g.startsWith("[")) {
					nextWord.setWord(g.substring(1, g.length()-1));
					
					// add phonetic reps generated by pho rule
					
						IPhoneticRep tRep = $g.targetReps.get(phoRepIndex);
						if(tRep != null) {
							IPhoneticRep rtRep = nextWord.getPhoneticRepresentation(Form.Target);
							rtRep.setPhones(tRep.getPhones());
						}
						
						IPhoneticRep aRep = $g.actReps.get(phoRepIndex);
						if(aRep != null) {
							IPhoneticRep raRep = nextWord.getPhoneticRepresentation(Form.Actual);
							raRep.setPhones(aRep.getPhones());
						}
						
						PhoneMap pm = Aligner.getPhoneAlignment(nextWord);
                    	if(pm != null) nextWord.setPhoneAlignment(pm);
						
						phoRepIndex++;
					
				} else {
					nextWord.setWord(g);
				}
				
			}
			
			// finish 'global' group
			IWord endGrpWord = $u::utt.newWord();
			endGrpWord.setWord("}");
		} else {
			$ugrp::w.setWord(
				($ugrp::w.getWord().length() > 0 ? $ugrp::w.getWord() + " " : "") +
				"{" +  $g.val + "}" );
		}
	}
	;
	
uannotation
	:	s
	{
		// add separator to last group
		List<IWord> words = $u::utt.getWords();
		if(words.size() == 0) {
			words.add($u::utt.newWordGroup());
			$u::useLastGroup = true;
		}
		IWord lastWord = 
			words.get(words.size()-1);
		lastWord.setWord(lastWord.getWord() + " " + $s.val);
	}
	|	pause
	{
		// add pause to last group as a comment
		List<IWord> words = $u::utt.getWords();
		if(words.size() == 0) {
			words.add($u::utt.newWordGroup());
			$u::useLastGroup = true;
		}
		IWord lastWord = 
			words.get(words.size()-1);
		lastWord.setWord(lastWord.getWord() + " " + $pause.val);
	}
	|	e
	{
		// add event to last group
		// add pause to last group as a comment
		List<IWord> words = $u::utt.getWords();
		if(words.size() == 0) {
			words.add($u::utt.newWordGroup());
			$u::useLastGroup = true;
		}
		IWord lastWord = 
			words.get(words.size()-1);
		lastWord.setWord(lastWord.getWord() + " " + $e.val);
	}
	|	linker
	{
		List<IWord> words = $u::utt.getWords();
		if(words.size() == 0) {
			words.add($u::utt.newWordGroup());
			$u::useLastGroup = true;
		}
		IWord lastWord = 
			words.get(words.size()-1);
		lastWord.setWord(lastWord.getWord() + " " + $linker.val);
	}
	|	tagmarker
	{
		List<IWord> words = $u::utt.getWords();
		if(words.size() == 0) {
			words.add($u::utt.newWordGroup());
			$u::useLastGroup = true;
		}
		IWord lastWord = 
			words.get(words.size()-1);
		lastWord.setWord(lastWord.getWord() + " " + $tagmarker.val);
	}
	;
]]>
    </buffer>
	
	<buffer name="Phon2XmlWalker.g">
		<![CDATA[
u
	:	^(U_START U_ATTR_WHO? (contentlist+=uele)* t? postcode? media? (annotationlist+=a)*)
	->	template(
			who={$U_ATTR_WHO.text},
			ucontent={$contentlist},
			terminator={$t.st},
			pc={$postcode.st},
			segment={$media.st},
			annotations={$annotationlist},
			uttid={uttIndex++}
		)
	<<
\<u who="<who>" uID="u<uttid>"\>
	<ucontent; separator="">
	<terminator>
	<pc>
	<segment>
	<annotations; separator="">
\</u\>
	>>
	;
	
uele
	:	ugrp
	->	template( v={$ugrp.st} )
		"<v>"
	|	uannotation
	->	template( v={$uannotation.st} )
		"<v>"
	;
	
uannotation
	: 	s 
	->	template( v={$s.st} )
		"<v>"
	|	pause
	->	template( v={$pause.st} )
		"<v>"
	|	e
	->	template( v={$e.st} )
		"<v>"
	|	linker
	->	template( v={$linker.st} )
		"<v>"
	|	tagmarker
	->	template( v={$tagmarker.st} )
		"<v>"
	;
	

ugrp
	:	w 
	->	template( v={$w.st} )
		"<v>"
	|	pg
	->	template( v={$pg.st} )
		"<v>"
	|	g
	-> 	template( v={$g.st} )
		"<v>"
	;
]]>
	</buffer>

    
    <!-- Includes -->
    <include>w.xml</include>
    <include>pg.xml</include>
    <include>g.xml</include>
    <include>s.xml</include>
    <include>pause.xml</include>
    <include>e.xml</include>
    <include>t.xml</include>
    <include>media.xml</include>
    <include>a.xml</include>
	<include>postcode.xml</include>
	<include>linker.xml</include>
	<include>tagmarker.xml</include>

    
</chunk>
