<?xml version="1.0" encoding="UTF-8"?>

<!-- 
Word
XPath - /xs:schema/xs:complexType[@name="wordType"]
-->
<chunk xmlns="http://phon.ling.mun.ca/ns/chunk">
    
    <!-- Parser -->
    <buffer name="Chat.g">
        <![CDATA[
w
	:	W_START wattr* langs? wele* W_END 
	->	^(W_START wattr* langs? wele*)
	;
	
wele
	:	TEXT 
	|	overlappoint
	|	underline
	|	italic
	|	shortening
	|	p
	|	longfeature
	|	wk 
	|	pos
	|	replacement
	|	mor
	|	mk
	;
	
wattr
	:	W_ATTR_SEPARATEDPREFIX
	|	W_ATTR_FORMTYPE
	|	W_ATTR_TYPE
	|	W_ATTR_USERSPECIALFORM
	|	W_ATTR_FORMSUFFIX
	|	W_ATTR_UNTRANSCRIBED
	;
]]>
    </buffer>
    
    <!-- Tree Walker -->
    <buffer name="ChatTree.g">
        <![CDATA[
w returns [String val]
scope {
	String buffer;
	String suffix;
	String prefix;
}
@init {
	$w::buffer = new String();
	$w::suffix = "";
	$w::prefix = "";
}
@after {
	$val = $w::prefix + $w::buffer.toString() + $w::suffix;
}
	:	^(W_START wattr* langs? wele*)
	{
		if($langs != null) {
			$w::buffer = $langs.val + $w::buffer;
		}
	}
	;
	
wele
	:	TEXT
	{	
		$w::buffer += ($w::buffer.length() > 0 ? "" : "") + $TEXT.text;	
	}
	|	overlappoint
	|	underline
	{
		$w::buffer += ($w::buffer.length() > 0 ? " " : "") + $underline.val;
	}
	|	italic
	{
		$w::buffer += ($w::buffer.length() > 0 ? " " : "") + $italic.val;
	}
	|	shortening
	{
		$w::buffer += ($w::buffer.length() > 0 ? "" : "") + $shortening.val;
	}
	|	p 
	{
		$w::buffer += ($w::buffer.length() > 0 ? "" : "") + $p.val;
	}
	|	longfeature
	| 	wk
	{
		$w::buffer += ($w::buffer.length() > 0 ? "" : "") + $wk.val;
	}
	|	pos
	|	replacement
	{
		$w::buffer += ($w::buffer.length() > 0 ? " " : "") + $replacement.val;
	}
	|	mor
	{
		// mor is handled as a seperate dependent tier
	}
	|	mk
	{
	}
	;
	
wattr
	:	W_ATTR_SEPARATEDPREFIX
	|	W_ATTR_FORMTYPE
	{
		$w::suffix = "@";
		
		String t = $W_ATTR_FORMTYPE.text;
		if(t.equals("babbling")) {
			$w::suffix += "b";
		} else if(t.equals("child-invented")) {
			$w::suffix += "c";
		} else if(t.equals("dialect")) {
			$w::suffix += "d";
		} else if(t.equals("family-specific")) {
			$w::suffix += "f";
		} else if(t.equals("filled pause")) {
			$w::suffix += "fp";
		} else if(t.equals("filler syllable")) {
			$w::suffix += "fs";
		} else if(t.equals("generic")) {
			$w::suffix += "g";
		} else if(t.equals("interjection")) {
			$w::suffix += "i";
		} else if(t.equals("kana")) {
			$w::suffix += "k";
		} else if(t.equals("letter")) {
			$w::suffix += "l";
		} else if(t.equals("neologism")) {
			$w::suffix += "n";
		} else if(t.equals("no voice")) {
			$w::suffix += "nv";
		} else if(t.equals("onomatopoeia")) {
			$w::suffix += "o";
		} else if(t.equals("phonology consistent")) {
			$w::suffix += "p";
		} else if(t.equals("proto-morpheme")) {
			$w::suffix += "pm";
		} else if(t.equals("quoted metareference")) {
			$w::suffix += "q";
		} else if(t.equals("sign speech")) {
			$w::suffix += "sas";
		} else if(t.equals("singing")) {
			$w::suffix += "si";
		} else if(t.equals("signed language")) {
			$w::suffix += "sl";
		} else if(t.equals("test")) {
			$w::suffix += "t";
		} else if(t.equals("UNIBET")) {
			$w::suffix += "u";
		} else if(t.equals("words to be excluded")) {
			$w::suffix += "x";
		} else if(t.equals("word play")) {
			$w::suffix += "wp";
		}
	}
	|	W_ATTR_TYPE
	{
		String t = $W_ATTR_TYPE.text;
		if(t.equals("unintelligible-word")) {
			$w::prefix = "xx";
		} else if(t.equals("unintelligible")) {
			$w::prefix = "xxx";
		} else if(t.equals("unintelligible-word-with-pho")) {
			$w::prefix = "yy";
		} else if(t.equals("unintelligible-with-pho")) {
			$w::prefix = "yyy";
		} else if(t.equals("untranscribed")) {
			$w::prefix = "www";
		} else if(t.equals("action")) {
			$w::prefix = "0";
		} else if(t.equals("omission")) { 
			$w::prefix = "0";
		} else if(t.equals("ellipsis")) {
			$w::prefix = "00";
		} else if(t.equals("fragment")) {
			$w::prefix = "&";
		}
	}
	|	W_ATTR_USERSPECIALFORM
	|	W_ATTR_FORMSUFFIX
	|	W_ATTR_UNTRANSCRIBED
	;
]]>
    </buffer>
	
	<buffer name="Phon2XmlWalker.g">
		<![CDATA[
w
	:	^(W_START (wattrlist+=wattr)* langs? (contentlist+=wele)* )
	->	{$wattrlist != null}? template( content={$contentlist}, l={$langs != null ? $langs.st : new String()}, wattrs={$wattrlist} )
		"\<w <wattrs; separator=\"\">\><l><content; separator=\"\">\</w\>"
	->	template( l={$langs != null ? $langs.st : new String()}, content={$contentlist} )
		"\<w\><l><content; separator=\"\">\</w\>"
	;
	
wele
	:	TEXT
	->	template( v={$TEXT.text} )
		"<v>"
	|	overlappoint
	->	template( v={$overlappoint.text} )
		"<v>"
	|	underline
	->	template( v={$underline.st} )
		"<v>"
	|	italic
	->	template( v={italic.st} )
		"<v>"
	|	shortening
	->	template( v={$shortening.st} )
		"<v>"
	|	p
	->	template( v={$p.st} )
		"<v>"
	|	longfeature
	->	template( v={$longfeature.st} )
		"<v>"
	|	wk
	->	template( v={$wk.st} )
		"<v>"
	|	pos
	->	template( v={$pos.st} )
		"<v>"
	
	|	replacement
	->	template( v={$replacement.st} )
		"<v>"
	|	mor
	->	template( v={$mor.st} )
		"<v>"
	|	mk
	->	template( v={$mk.st} )
		"<v>"
	;
	
wattr
	:	W_ATTR_SEPARATEDPREFIX
	->	template( v={$W_ATTR_SEPARATEDPREFIX.text} )
	<<separated-prefix="<v>" >>
	|	W_ATTR_FORMTYPE
	->	template( v={$W_ATTR_FORMTYPE.text} )
	<<formType="<v>" >>
	|	W_ATTR_TYPE
	->	template( v={$W_ATTR_TYPE.text} )
	<<type="<v>" >>
	|	W_ATTR_USERSPECIALFORM
	->	template( v={$W_ATTR_USERSPECIALFORM.text} )
	<<user-special-form="<v>" >>
	|	W_ATTR_FORMSUFFIX
	->	template( v={$W_ATTR_FORMSUFFIX.text} )
	<<form-suffix="<v>" >>
	|	W_ATTR_UNTRANSCRIBED
	->	template( v={$W_ATTR_UNTRANSCRIBED.text} )
	<<untranscribed="<v>" >>
	;
]]>
	</buffer>
	
    <!-- Includes -->
	<include>langs.xml</include>
    <include>overlappoint.xml</include>
    <include>underline.xml</include>
	<include>italic.xml</include>
	<include>shortening.xml</include>
	<include>p.xml</include>
	<include>longfeature.xml</include>
	<include>wk.xml</include>
	<include>pos.xml</include>
	<include>replacement.xml</include>
	<include>mor.xml</include>
	<include>mk.xml</include>
</chunk>
