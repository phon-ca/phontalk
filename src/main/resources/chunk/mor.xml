<?xml version="1.0" encoding="UTF-8"?>

<!-- 
    mor data
-->
<chunk xmlns="http://phon.ling.mun.ca/ns/chunk">
    
    <!-- Parser -->
    <buffer name="Chat.g">
        <![CDATA[
mor
    :    MOR_START MOR_ATTR_TYPE MOR_ATTR_OMITTED? morchoice menx* gra* morseq* MOR_END
    ->    ^(MOR_START MOR_ATTR_TYPE MOR_ATTR_OMITTED? morchoice menx* gra* morseq*)
    ;
    
morchoice
    :    mw
    |    mwc
    |    mt
    ;
    
morseq
    :    mor_pre
    |    mor_post
    ;
    
mor_pre
    :    MOR_PRE_START morchoice menx* gra* MOR_PRE_END
    ->    ^(MOR_PRE_START morchoice menx* gra*)
    ;
    
mor_post
    :    MOR_POST_START morchoice menx* gra* MOR_POST_END
    ->    ^(MOR_POST_START morchoice menx* gra*)
    ;
    
menx
    :    MENX_START TEXT MENX_END
    ;
    
gra
    :    GRA_START graattrs+ GRA_END
    ->    ^(GRA_START graattrs+)
    ;
    
graattrs
    :    GRA_ATTR_TYPE
    |    GRA_ATTR_INDEX
    |    GRA_ATTR_HEAD
    |    GRA_ATTR_RELATION
    ;
    
mw
    :    MW_START mpfx* pos stem mk* MW_END
    ->    ^(MW_START mpfx* pos stem mk*)
    ;
    
mwc
    :    MWC_START mpfx* pos mw+ MWC_END
    ->    ^(MWC_START mpfx* pos mw+)
    ;
    
mt
    :    MT_START MT_ATTR_TYPE MT_END
    ->    ^(MT_START MT_ATTR_TYPE)
    ;
    
mpfx
    :    MPFX_START TEXT MPFX_END
    ->    ^(MPFX_START TEXT)
    ;
   
pos
    :    POS_START morposc morposs* POS_END
    ->    ^(POS_START morposc morposs*)
    ;
    
morposc
    :    C_START TEXT C_END
    ->    ^(C_START TEXT)
    ;
    
morposs
    :    S_START TEXT S_END
    ->    ^(S_START TEXT)
    ;
    
stem
    :    STEM_START TEXT STEM_END
    ->    ^(STEM_START TEXT);
    
mk
    :    MK_START MK_ATTR_TYPE TEXT MK_END
    ->    ^(MK_START MK_ATTR_TYPE TEXT)
    ;
    

]]>
    </buffer>
    
    <!-- Tree Walker -->
    <buffer name="ChatTree.g">
        <![CDATA[
mor
scope
{
    List<String> morPres;
    List<String> morPosts;
}
@init
{
    $mor::morPres = new ArrayList<String>();
    $mor::morPosts = new ArrayList<String>();
}
    :    ^(MOR_START MOR_ATTR_TYPE MOR_ATTR_OMITTED? morchoice menx* gra* morseq*)
    {
        // make sure dep tier exists in session
		IDepTierDesc tierDesc = null;
		for(IDepTierDesc current:session.getWordAlignedTiers())
		{
			if(current.getTierName().equals("Morphology"))
			{
				tierDesc = current;
				break;
			}
		}
		
		if(tierDesc == null) {
			// create the new tier
			tierDesc = session.newDependentTier();
			tierDesc.setTierName("Morphology");
			tierDesc.setIsGrouped(true);
		}
		
		// add mor data as a dep tier of the current word(group)
		IWord word = ($t.size() > 0 ? $t::w : $ugrp::w);
		IDependentTier depTier = 
		    word.getDependentTier(tierDesc.getTierName());
		if(depTier == null) {
			depTier = word.newDependentTier();
			depTier.setTierName(tierDesc.getTierName());
		}
		String tierValue = depTier.getTierValue();
		tierValue += 
		    (tierValue.length() == 0 ? "" : " ") + $morchoice.val;
		    
		for(String morPre:$mor::morPres) {
		    tierValue = morPre + "&" + tierValue;
		}
		for(String morPost:$mor::morPosts) {
		    tierValue += "~" + morPost;
		}
		depTier.setTierValue(tierValue);
    }
    ;
    
morattr
    :    MOR_ATTR_TYPE
    {
        if(!$MOR_ATTR_TYPE.text.equals("mor")) {
            PhonLogger.warning("Only support <mor> elements with type set to 'mor'.");
        }
    }
    |    MOR_ATTR_OMITTED
    ;
    
morchoice returns [String val]
    :    mw
    {    $val = $mw.val;    }
    |    mwc
    {    $val = $mwc.val;    }
    |    mt
    {    $val = $mt.val;    }
    ;
    
morseq returns [String val]
    :    mor_pre
    {    $val = $mor_pre.val;    }
    |    mor_post
    {    $val = $mor_post.val;    }
    ;
    
mor_pre returns [String val]
    :    ^(MOR_PRE_START morchoice menx* gra*)
    {
        $val = $morchoice.val;
    }
    ;
    
mor_post returns [String val]
@after
{
    $mor::morPosts.add($val);
}
    :    ^(MOR_POST_START morchoice menx* gra*)
    {
        $val = $morchoice.val;
    }
    ;
    
menx returns [String val]
    :    MENX_START TEXT MENX_END
    {
        $val = $TEXT.text;
    }
    ;

gra returns [String val]
scope
{
    String type;
    String index;
    String head;
    String relation;
}
    :    ^(GRA_START graattrs+)
    {
        // make sure dep tier exists in session
		IDepTierDesc tierDesc = null;
		for(IDepTierDesc current:session.getWordAlignedTiers())
		{
			if(current.getTierName().equals("GRASP"))
			{
				tierDesc = current;
				break;
			}
		}
		
		if(tierDesc == null) {
			// create the new tier
			tierDesc = session.newDependentTier();
			tierDesc.setTierName("GRASP");
			tierDesc.setIsGrouped(true);
		}
		
		// value
		$val = $gra::index + "|" + $gra::head + "|" + $gra::relation;
		
		// add mor data as a dep tier of the current word(group)
		IWord word = ($t.size() > 0 ? $t::w : $ugrp::w);
		IDependentTier depTier = 
		    word.getDependentTier(tierDesc.getTierName());
		if(depTier == null) {
			depTier = word.newDependentTier();
			depTier.setTierName(tierDesc.getTierName());
		}
		String tierValue = depTier.getTierValue();
		tierValue += 
		    (tierValue.length() == 0 ? "" : " ") + $val;
		depTier.setTierValue(tierValue);
    }
    ;
    
graattrs
    :    GRA_ATTR_TYPE
    {    $gra::type = $GRA_ATTR_TYPE.text;    }
    |    GRA_ATTR_INDEX
    {    $gra::index = $GRA_ATTR_INDEX.text;    }
    |    GRA_ATTR_HEAD
    {    $gra::head = $GRA_ATTR_HEAD.text;    }
    |    GRA_ATTR_RELATION
    {    $gra::relation = $GRA_ATTR_RELATION.text;    }
    ;
    
mw returns [String val]
scope
{
    List<String> mpfxVals;
    List<Tuple<String, String>> mkVals;
}
@init
{
    $mw::mpfxVals = new ArrayList<String>();
    $mw::mkVals = new ArrayList<Tuple<String, String>>();
}
@after {
    // add to compound word if we are inside a <mwc> container
    if($mwc.size() > 0) {
        $mwc::mwVals.add($val);
    }
}
    :   ^(MW_START mpfx* pos stem mk*)
    {
        // simplest case, pos + single choice 
        $val = $pos.val + "|" + $stem.val;
        
        // add mpfx vals if any
        for(String v:$mw::mpfxVals) {
            $val = v + "#" + $val;
        }
        
        // add mk vals if any
        for(Tuple<String, String> v:$mw::mkVals) {
            String suffix = v.getObj1();
            String type = v.getObj2();
            
            String prefix = "";
            if(type.equals("sfx")) {
                prefix = "-";
            } else if(type.equals("sfxf")) {
                prefix = "&";
            } else if(type.equals("mc")) {
                prefix = ":";
            }
            
            $val += prefix + suffix;
        }
    }
    ;
    
mwc returns [String val]
scope
{
    List<String> mwVals;
    List<String> mpfxVals;
    boolean inMwc;
}
@init
{
    $mwc::inMwc = true;
    $mwc::mpfxVals = new ArrayList<String>();
    $mwc::mwVals = new ArrayList<String>();
}
@after
{
    $mwc::inMwc = false;
}
    :    ^(MWC_START mpfx* pos mw+)
    {
        $val = $pos.val + "|";
        for(String v:$mwc::mwVals) {
            $val += "+" + v;
        }
        
        for(String v:$mwc::mpfxVals) {
            $val = v + "#" + $val;
        }
    }
    ;
    
mt returns [String val]
    :    ^(MT_START MT_ATTR_TYPE)
    {
        String t = $MT_ATTR_TYPE.text;
        if(t.equals("p")) {
		   $val = ".";
		} else if(t.equals("q")) {
		    $val = "?";
		} else if(t.equals("e")) {
		    $val = "!";
		} else {
		    // wrap in paren
		    $val = "(mt:" + t + ")";
		}
    }
    ;
    
mpfx returns [String val]
@after {
    if($mw.size() > 0) {
        $mw::mpfxVals.add($val);
    } else if($mwc.size() > 0) {
        $mwc::mpfxVals.add($val);
    }
}
    :    ^(MPFX_START TEXT)
    {
        $val = $TEXT.text;
    }
    ;
   
pos returns [String val]
scope
{
    List<String> sVals;
}
@init
{
    $pos::sVals = new ArrayList<String>();
}
    :    ^(POS_START morposc morposs*)
    {
        $val = $morposc.val;
        for(String s:$pos::sVals) {
            $val += ":" + s;
        }
    }
    ;
    
morposc returns [String val]
    :    ^(C_START TEXT)
    {
        $val = $TEXT.text;
    }
    ;
    
morposs returns [String val]
@after {
    $pos::sVals.add($val);
}
    :    ^(S_START TEXT)
    {
        $val = $TEXT.text;
    }
    ;
    
stem returns [String val]
    :    ^(STEM_START TEXT)
    {
        $val = $TEXT.text;
    }
    ;
    
mk returns [String val, String type]
@after {
    if($mw.size() > 0) {
        $mw::mkVals.add(new Tuple<String, String>($val, $type));
    }
}
    :    ^(MK_START MK_ATTR_TYPE TEXT)
    {
        $val = $TEXT.text;
        $type = $MK_ATTR_TYPE.text;
    }
    ;
]]>
    </buffer>
    
    <buffer name="Phon2XmlWalker.g">
        <![CDATA[
mor
    :    ^(MOR_START morattr* morchoice* gra? morseq*)
    ;
    
morattr
    :    MOR_ATTR_TYPE
    |    MOR_ATTR_OMITTED
    ;
    
morchoice
    :    mw
    |    mwc
    |    mt
    ;
    
morseq
    :    morpre
    |    morpost
    |    menx
    ;
    
morpre
    :    ^(MORPRE_START morattr* morchoice* gra? morseq*)
    {
        unsupportedWarning();
    }
    ;
    
morpost
    :    ^(MORPOST_START morattr* morchoice* gra? morseq*)
    {
        unsupportedWarning();
    }
    ;
    
menx
    :    MENX_START TEXT MENX_END
    {
        unsupportedWarning();
    }
    ;
    
gra
    :    ^(GRA_START GRA_ATTR_TYPE GRA_ATTR_INDEX GRA_ATTR_HEAD GRA_ATTR_RELATION)
    {
        unsupportedWarning();
    }
    ;
    
mw
    :    ^(MW_START mpfx* pos mwchoice mk*)
    ;
    
mwc
    :    ^(MWC_START mpfx* pos mw+)
    {
        unsupportedWarning();
    }
    ;
    
mt
    :    ^(MT_START MT_ATTR_TYPE)
    {
        unsupportedWarning();
    }
    ;
    
mpfx
    :    ^(MPFX_START TEXT)
    {
        unsupportedWarning();
    }
    ;
   
pos
    :    ^(POS_START morposc morposs*)
    ;
    
morposc
    :    ^(C_START TEXT)
    ;
    
morposs
    :    ^(S_START TEXT)
    ;
    
mwchoice
    :    stem
    |    mortagmarker
    ;
    
stem
    :    ^(STEM_START TEXT);
    
mortagmarker
    :    ^(MORTAGMARKER_START MORTAGMARKER_ATTR_TYPE)
    ;
    
mk
    :    ^(MK_START TEXT)
    ;
]]>
    </buffer>
    
</chunk>