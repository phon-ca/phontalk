<?xml version="1.0" encoding="UTF-8"?>

<!-- 
Group type
XPath - /xs:schema/xs:complexType[@name="groupType"]
-->
<chunk xmlns="https://www.phon.ca/ns/chunk">
    
    <!-- Parser -->
    <buffer name="Chat.g">
        <![CDATA[
g	
	:	G_START gele+ gchoice* G_END 
	->	^(G_START gele+ gchoice*)
	;
	
gele
	:	w
	|	pg
	|	sg
	|	quotation
	|	quotation2
	|	pause
	|	internal_media
	|	freecode
	|	e
	|	s
	|	tagmarker
	|	longfeature
	|	nonvocal
	|	overlap_point
	|	underline
	|	italic
	;
	
gchoice
	:	k
	|	error
	|	r
	|	duration
	|	ga
	|	overlap
	;
]]>
    </buffer>
    
    <!-- Tree Walker -->
    <buffer name="ChatTree.g">
        <![CDATA[
g returns [String val,  Integer phoRepCount, Map<Integer,IPhoneticRep> targetReps, Map<Integer, IPhoneticRep> actReps, Map<Integer, PhoneMap> phoneMaps]
scope {
	String buffer;
	
	// when g has <pg> children store the
 	// phonetic rep objects generated in the
 	// pho rule
 	Map<Integer, IPhoneticRep> tReps;
 	Map<Integer, IPhoneticRep> aReps;
	Map<Integer, PhoneMap> pMaps;
 	
 	int pgCount;
}
@init {
	$g::buffer = new String();
	
	$g::tReps = new HashMap<Integer, IPhoneticRep>();
	$g::aReps = new HashMap<Integer, IPhoneticRep>();
	$g::pMaps = new HashMap<Integer, PhoneMap>();
	
	$g::pgCount = 0;
}
@after {
	$val = $g::buffer;
	
	$targetReps = $g::tReps;
	$actReps = $g::aReps;
	$phoneMaps = $g::pMaps;
	
	$phoRepCount = $g::pgCount;
}
	:	^(G_START gele+ gchoice*)
	;
	
gele
	:	w 
	{	
		$g::buffer += ($g::buffer.length() > 0 ? " " : "") + $w.val;	
	}
	|	nestedg=g
	{
		$g::buffer += ($g::buffer.length() > 0 ? " " : "") +
			"{]" + $nestedg.val + "}]"; 	
		
		Integer[] targetKeys = $nestedg.targetReps.keySet().toArray(new Integer[0]);
		for(Integer targetKey:targetKeys) {
			int newKey = targetKey + $g::pgCount;
			$g::tReps.put(newKey, $nestedg.targetReps.get(targetKey));
		}
		
		Integer[] actualKeys = $nestedg.actReps.keySet().toArray(new Integer[0]);
		for(Integer actualKey:actualKeys) {
			int newKey = actualKey + $g::pgCount;
			$g::aReps.put(newKey, $nestedg.actReps.get(actualKey));
		}
		
		Integer[] pMapKeys = $nestedg.phoneMaps.keySet().toArray(new Integer[0]);
		for(Integer pmapKey:pMapKeys) {
			int newKey = pmapKey + $g::pgCount;
			$g::pMaps.put(pmapKey, $nestedg.phoneMaps.get(pmapKey));
		}

		$g::pgCount += $nestedg.phoRepCount;
	}
	|	pg
	{
	 	// enclose the pg data in [] so that we know to break up
	 	// this into proper word groups in phon later.
		$g::buffer += ($g::buffer.length() > 0 ? " " : "") + "[" + $pg.val + "]";
	}
	|	sg
	|	quotation
	|	quotation2
	|	pause
	{
		$g::buffer += ($g::buffer.length() > 0 ? " " : "") + $pause.val;
	}
	|	internal_media
	{
		$g::buffer += ($g::buffer.length() > 0 ? " " : "") + $internal_media.val;
	}
	|	freecode
	|	e
	{
		$g::buffer += ($g::buffer.length() > 0 ? " " : "") +
			$e.val;
	}
	
	|	s
	{
		$g::buffer += ($g::buffer.length() > 0 ? " " : "") +
			$s.val;
	}
	|	tagmarker
	{
		$g::buffer += ($g::buffer.length() > 0 ? " " : "") +
			"(" + $tagmarker.val + ")";
	}
	|	longfeature
	|	nonvocal
	|	overlap_point
	{
		$g::buffer += ($g::buffer.length() > 0 ? " " : "") +
			$overlap_point.val;
	}
	|	underline
	{
		$g::buffer += ($g::buffer.length() > 0 ? " " : "") +
			$underline.val;
	}
	|	italic
	;
	
gchoice
	: 	k
	{
		$g::buffer += ($g::buffer.length() > 0 ? " " : "") + 
			"(" + $k.val + ")";
	}
	|	error
	{
		$g::buffer += ($g::buffer.length() > 0 ? " " : "") +
			$error.val;
	}
	| 	r 
	{	
		$g::buffer += ($g::buffer.length() > 0 ? " " : "") + 
			"(x" + $r.val + ")";	
	}
	|	duration
	|	ga
	{
		$g::buffer += ($g::buffer.length() > 0 ? " " : "") +
			$ga.val;
	}
	|	overlap
	{
		$g::buffer += ($g::buffer.length() > 0 ? " " : "") +
			"(" + $overlap.val + ")";
	}
	;
]]>
    </buffer>
	
	<buffer name="Phon2XmlWalker.g">
		<![CDATA[
g	
	:	^(G_START (contentlist+=gele)+ (choicelist+=gchoice)*)
	->	template( content={$contentlist}, choices={$choicelist} )
	<<\<g\><content; separator=""><if(choices)><choices; separator=""><endif>\</g\> >>
	;
	
gele
	:	w 
	->	template( v={$w.st} )
		"<v>"
	|	g
	->	template( v={$g.st} )
		"<v>"
	|	pg
	->	template( v={$pg.st} )
		"<v>"
	|	sg
	|	quotation
	|	quotation2
	|	pause
	->	template( v={$pause.st} )
		"<v>"
	|	internal_media
	->	template( v={$internal_media.st} )
		"<v>"
	|	freecode
	|	e
	->	template( v={$e.st} )
		"<v>"
	|	s
	->	template( v={$s.st} )
		"<v>"
	|	tagmarker
	->  template( v={$tagmarker.st} )
		"<v>"
	|	longfeature
	|	nonvocal
	|	overlap_point
	->	template( v={$overlap_point.st} )
		"<v>"
	|	underline
	->	template( v={$underline.st} )
		"<v>"
	|	italic
	;
	
gchoice
	:	k
	->	template( v={$k.st} )
		"<v>"
	|	error
	->	template( v={$error.st} )
		"<v>"
	|	r 
	->	template( v={$r.st} )
		"<v>"
	|	duration
	|	ga
	->	template( v={$ga.st} )
		"<v>"
	|	overlap
	->	template( v={$overlap.st} )
		"<v>"
	;
]]>
	</buffer>
    
    <!-- Includes -->
	<include>w.xml</include>
	<include>g.xml</include>
	<include>pg.xml</include>
	<include>sg.xml</include>
    <include>quotation.xml</include>
	<include>quotation2.xml</include>
	<include>pause.xml</include>
	<include>internal-media.xml</include>
	<include>freecode.xml</include>
	<include>e.xml</include>
	<include>s.xml</include>
	<include>tagmarker.xml</include>
	<include>longfeature.xml</include>
	<include>nonvocal.xml</include>
	<include>overlappoint.xml</include>
	<include>underline.xml</include>
	<include>italic.xml</include>
	<include>k.xml</include>
	<include>error.xml</include>
	<include>r.xml</include>
	<include>duration.xml</include>
	<include>ga.xml</include>
	<include>overlap.xml</include>
	
</chunk>
