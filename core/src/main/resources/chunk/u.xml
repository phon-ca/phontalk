<?xml version="1.0" encoding="UTF-8"?>

<!-- 
Utterance
Schema - http://www.talkbank.org/software/talkbank.xsd
XPath -	/xs:schema/xs:complexType[@name="speakerUtteranceType"]
-->
<chunk xmlns="https://www.phon.ca/ns/chunk">
    
    <!-- Parser -->
    <buffer name="Chat.g">
        <![CDATA[
u
	:	U_START u_attrs* ( uele )* t? postcode? media? a* U_END 
	->	^(U_START u_attrs* uele* t? postcode? media? a*)
	;
	catch [RecognitionException re] {
		consumeUntil(input, U_END);
		input.consume(); // consume U_END
	}
	
u_attrs
	:	U_ATTR_WHO
	|	U_ATTR_LANG
	;
	
uele
	:	ugrp
	|	uannotation
	;
	
ugrp
	:	w 
	|	pg 
	|	g
	;
	
uannotation
	: 	s 
	|	pause 
	|	e
	|	linker
	|	tagmarker
	|	internal_media
	|	overlap_point
	;
]]>
    </buffer>
    
    <!-- Tree Walker -->
    <buffer name="ChatTree.g">
        <![CDATA[
u returns [Record record]
scope {
	Record r;
	
	// when adding annotations, sometimes we need to create
	// the first word-group.  This flag tells the next ugrp
	// element to use the last group instead of making a new one
	boolean useLastGroup;
	
	String who;
	String recordLang;
}
@init {
	$u::r = sessionFactory.createRecord();
	$u::useLastGroup = false;
	$u::who = null;
	$u::recordLang = null;
}
@after {
	$u.record = $u::r;
	++recordIndex;
}
	:	^(U_START u_attrs* uele* t? postcode? seg=media? a*)
	{
		// setup speaker
		if($u::who != null) 
		{
			// try to find the speaker
			String partId = $u::who;
			
			// by id first
			for(Participant p:session.getParticipants()) {
				if(p.getId().equals(partId)) {
					$u::r.setSpeaker(p);
					break;
				}
			}
			
		}
		
		// set media if avail
		if($seg.val != null)
		{
			$u::r.getSegment().setGroup(0, $seg.val);
		}
		
		if($u::recordLang != null) {
			// make sure the uttlang tier exists in session
			TierDescription langTierDesc = ensureTierExists("uttlang", false);
			
			Tier<String> langTier = $u::r.getTier(langTierDesc.getName(), String.class);
			if(langTier == null) {
				langTier = sessionFactory.createTier(langTierDesc.getName(), String.class, true);
				$u::r.putTier(langTier);
			}
			langTier.setGroup(0, $u::recordLang);
		}
		
		// add comments if necessary
		if(nextRecordComments.size() > 0) {
			nextRecordComments.forEach( c -> $u.record.addComment(c) );
			nextRecordComments.clear();
		}
		
		$u.record = $u::r;
	}
	;
	
u_attrs
	:	U_ATTR_WHO
	{
		$u::who = $U_ATTR_WHO.text;
	}
	|	U_ATTR_LANG
	{
		$u::recordLang = $U_ATTR_LANG.text;
	}
	;

uele
	:	ugrp
	|	uannotation
	;

/**
 * Each ugrp object creates a new group in Phon.
 */
 ugrp returns [Group group]
 scope {
 	Group g;
 }
 @init {
 	if($u::useLastGroup) {
 		$ugrp::g = $u::r.getGroup($u::r.numberOfGroups()-1);
 		
 		// reset flag
 		$u::useLastGroup = false;
 	} else {
 		$ugrp::g = $u::r.addGroup();
 	}
 }
@after {
 	$ugrp.group = $ugrp::g;
}
	:	w 
	{	
		OrthographyBuilder builder = new OrthographyBuilder();
		builder.append($ugrp::g.getOrthography()).append($w.val);
		$ugrp::g.setOrthography(builder.toOrthography());
	}
	| 	pg 
	{	
		OrthographyBuilder builder = new OrthographyBuilder();
		builder.append($ugrp::g.getOrthography()).append($pg.val);
		$ugrp::g.setOrthography(builder.toOrthography());
	}
	| 	g
	{	
		// we may need to break data up into more words
		// check to see if we have sub-[] enclosures
		String gData = $g.val;
		if(gData.contains("[") || gData.contains("]")) {
			// break up data
			List<String> grps = new ArrayList<String>();
			String currentGrp = "";
			for(int i = 0; i < gData.length(); i++) {
				char c = gData.charAt(i);
				
				if(c == '[') {
	                if(currentGrp.trim().length() > 0) {
	                    grps.add(currentGrp.trim());
	                }
	                currentGrp = "";
	            }
	            currentGrp += c;
	            if(c == ']') {
	                if(currentGrp.trim().length() > 0) {
	                    grps.add(currentGrp.trim());
	                }
	                currentGrp = "";
	            }
					
			}
			if(currentGrp.trim().length() > 0) {
				grps.add(currentGrp.trim());
			}
			// place only an openeing '{' in our first group
			// this tells the tree builder   to create this group surrounding the 
			// next <pg> groups
			$ugrp::g.setOrthography(
				(new OrthographyBuilder()).append("{").toOrthography());
			
			// if we have sub-pg groups.  The new words should have been created.
			int phoRepIndex = 0;
			for(String g:grps) {
				Group nextGroup = $u::r.addGroup();
				
				if(g.startsWith("[")) {
					nextGroup.setOrthography(
						(new OrthographyBuilder()).append(g.substring(1, g.length()-1))
							.toOrthography());
					
					// add phonetic reps generated by pho rule
					IPATranscript tRep = $g.targetReps.get(phoRepIndex);
					if(tRep == null) tRep = new IPATranscript();
					nextGroup.setIPATarget(tRep);

					IPATranscript aRep = $g.actReps.get(phoRepIndex);
					if(aRep == null) aRep = new IPATranscript();
					nextGroup.setIPAActual(aRep);
					
					PhoneMap pm = new PhoneMap(tRep, aRep);
					nextGroup.setPhoneAlignment(pm);
						
					phoRepIndex++;
				} else {
					nextGroup.setOrthography(
						(new OrthographyBuilder()).append(g).toOrthography());
				}
			}
			
			// finish 'global' group
			Group endGrp = $u::r.addGroup();
			endGrp.setOrthography(
				(new OrthographyBuilder()).append("}").toOrthography());
		} else {
			$ugrp::g.setOrthography(
				(new OrthographyBuilder()).append($ugrp::g.getOrthography())
					.append("{").append($g.val).append("}")
					.toOrthography());
		}
	}
	;
	
uannotation
	:	s
	{
		// add separator to last group
		Group lastGroup = 
			($u::r.numberOfGroups() > 0 ? $u::r.getGroup($u::r.numberOfGroups()-1) : $u::r.addGroup());
		lastGroup.setOrthography(
			(new OrthographyBuilder()).append(lastGroup.getOrthography())
				.append($s.val).toOrthography());
	}
	|	pause
	{
		// add pause to last group as a comment
		Group lastGroup = 
			($u::r.numberOfGroups() > 0 ? $u::r.getGroup($u::r.numberOfGroups()-1) : $u::r.addGroup());
		lastGroup.setOrthography(
			(new OrthographyBuilder()).append(lastGroup.getOrthography())
				.append($pause.val).toOrthography());
	}
	|	e
	{
		// add event to last group
		// add pause to last group as a comment
		Group lastGroup = 
			($u::r.numberOfGroups() > 0 ? $u::r.getGroup($u::r.numberOfGroups()-1) : $u::r.addGroup());
		lastGroup.setOrthography(
			(new OrthographyBuilder()).append(lastGroup.getOrthography())
				.append($e.val).toOrthography());
	}
	|	linker
	{
		Group lastGroup = 
			($u::r.numberOfGroups() > 0 ? $u::r.getGroup($u::r.numberOfGroups()-1) : $u::r.addGroup());
		lastGroup.setOrthography(
			(new OrthographyBuilder()).append(lastGroup.getOrthography())
				.append($linker.val).toOrthography());
	}
	|	tagmarker
	{
		Group lastGroup = 
			($u::r.numberOfGroups() > 0 ? $u::r.getGroup($u::r.numberOfGroups()-1) : $u::r.addGroup());
		lastGroup.setOrthography(
			(new OrthographyBuilder()).append(lastGroup.getOrthography())
				.append($tagmarker.val).toOrthography());
	}
	|	internal_media
	{
		Group lastGroup = 
			($u::r.numberOfGroups() > 0 ? $u::r.getGroup($u::r.numberOfGroups()-1) : $u::r.addGroup());
		lastGroup.setOrthography(
			(new OrthographyBuilder()).append(lastGroup.getOrthography())
				.append($internal_media.val).toOrthography());
	}
	|	overlap_point
	{
		Group lastGroup = 
			($u::r.numberOfGroups() > 0 ? $u::r.getGroup($u::r.numberOfGroups()-1) : $u::r.addGroup());
		lastGroup.setOrthography(
			(new OrthographyBuilder()).append(lastGroup.getOrthography())
				.append($overlap_point.val).toOrthography());
	}
	;
]]>
    </buffer>
	
	<buffer name="Phon2XmlWalker.g">
		<![CDATA[
u
	:	^(U_START (attrs+=u_attrs)* (contentlist+=uele)* t? postcode? media? (annotationlist+=a)*)
	->	template(
			attrlist={$attrs},
			ucontent={$contentlist},
			terminator={$t.st},
			pc={$postcode.st},
			segment={$media.st},
			annotations={$annotationlist},
			uttid={recordIndex++}
		)
	<<
\<u <attrlist; separator=" "> uID="u<uttid>"\>
	<ucontent; separator="">
	<terminator>
	<pc>
	<segment>
	<annotations; separator="">
\</u\>
	>>
	;
	
u_attrs
	:	U_ATTR_WHO
	->	template(who={$U_ATTR_WHO.text})
	<<who="<who>" >>
	|	U_ATTR_LANG
	->	template(lang={$U_ATTR_LANG.text})
	<<xml:lang="<lang>" >>
	;
	
uele
	:	ugrp
	->	template( v={$ugrp.st} )
		"<v>"
	|	uannotation
	->	template( v={$uannotation.st} )
		"<v>"
	;
	
uannotation
	: 	s 
	->	template( v={$s.st} )
		"<v>"
	|	pause
	->	template( v={$pause.st} )
		"<v>"
	|	e
	->	template( v={$e.st} )
		"<v>"
	|	linker
	->	template( v={$linker.st} )
		"<v>"
	|	tagmarker
	->	template( v={$tagmarker.st} )
		"<v>"
	|	internal_media
	->	template( v={$internal_media.st} )
		"<v>"
	|	overlap_point
	->	template( v={$overlap_point.st} )
		"<v>"
	;
	

ugrp
	:	w 
	->	template( v={$w.st} )
		"<v>"
	|	pg
	->	template( v={$pg.st} )
		"<v>"
	|	g
	-> 	template( v={$g.st} )
		"<v>"
	;
]]>
	</buffer>

    
    <!-- Includes -->
    <include>w.xml</include>
    <include>pg.xml</include>
    <include>g.xml</include>
    <include>s.xml</include>
    <include>pause.xml</include>
    <include>e.xml</include>
    <include>t.xml</include>
    <include>media.xml</include>
	<include>internalmedia.xml</include>
	<include>overlappoint.xml</include>
    <include>a.xml</include>
	<include>postcode.xml</include>
	<include>linker.xml</include>
	<include>tagmarker.xml</include>

    
</chunk>
